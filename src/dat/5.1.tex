Microscopic Maxwell's equations $ \vec{E}\left( \vec{r}, t \right) $, $ \vec{B}\left( \vec{r}, t \right) $, $ \vec{H}\left( \vec{r}, t \right) $, $ \vec{D}\left( \vec{r}, t \right) $:
\begin{equation}
\div{\vec{E}} = \frac{\rho}{\varepsilon_0}
\end{equation}
\begin{equation}
\div{\vec{B}} = 0
\end{equation}
\begin{equation}
\rot{\vec{E}} + \diffp{\vec{B}}{t} = 0
\end{equation}
\begin{equation}
\rot{\vec{B}} - \mu_0 \varepsilon_0 \diffp{\vec{E}}{t}= \mu_0 \vec{J}
\end{equation}
Macroscopic Maxwell's equations:
\begin{equation}
\div{\vec{D}} = \rho
\end{equation}
\begin{equation}
\div{\vec{B}} = 0
\end{equation}
\begin{equation}
\rot{\vec{E}} + \diffp{\vec{B}}{t} = 0
\end{equation}
\begin{equation}
\rot{\vec{H}} - \diffp{\vec{D}}{t} = \vec{J}
\end{equation}
where:
\begin{equation}
\vec{D} = \varepsilon_0 \vec{E} + \vec{P} = \varepsilon \vec{E}
\end{equation}
\begin{equation}
\vec{H} = \frac{\vec{B}}{\mu_0} - \vec{M} = \frac{\vec{B}}{\mu} 
\end{equation}
and $ \vec{P}\left(\vec{r} \right) $, $ \vec{M}\left( \vec{r} \right) $
continuity equation (conservation of charge):
\begin{equation}
\div{\vec{J}} + \diffp{\rho}{t} = 0
\end{equation}
E and B in potentials:
\begin{equation}
\vec{E} = -\grad{\phi} - \diffp{\vec{A}}{t}
\end{equation}
\begin{equation}
\vec{B} = \rot{\vec{A}}
\end{equation}
Lorenz gauge:
\begin{equation}
\div{\vec{A}} + \mu \varepsilon \diffp{\phi}{t} = 0
\end{equation}
then:
\begin{equation}
\left(\laplace{} - \mu \varepsilon \diffp[2]{}{t} \right)\phi = -\frac{\rho}{\varepsilon}
\end{equation}
\begin{equation}
\left(\laplace{} - \mu \varepsilon \diffp[2]{}{t} \right)\vec{A} = -\mu \vec{J}
\end{equation}
solutions:
\begin{equation}
\phi\left(\vec{r}, t \right) = \frac{1}{4 \pi \varepsilon} \int\limits_{V} \frac{\rho\left(\vec{\tilde{r}}, t \right)}{\abs{\vec{r} - \vec{\tilde{r}}}} \mathrm{d} \tilde{V}
\end{equation}
\begin{equation}
\vec{A}\left(\vec{r}, t \right) = \frac{\mu}{4 \pi} \int\limits_{V} \frac{\vec{J}\left(\vec{\tilde{r}}, t \right)}{\abs{\vec{r} - \vec{\tilde{r}}}} \mathrm{d} \tilde{V}
\end{equation}
Hertz vectors (under ordinary conditions):
\begin{equation}
\phi = - \div{\vec{\Pi_e}}
\end{equation}
\begin{equation}
\vec{A} = \mu \varepsilon \diffp{\vec{\Pi_e}}{t}
\end{equation}
\begin{equation}
\phi = 0
\end{equation}
\begin{equation}
\vec{A} = \rot{\vec{\Pi_m}}
\end{equation}
E and B in terms of electric Hertz vector:
\begin{equation}
\vec{E} = \grad{\left(\div{\vec{\Pi_e}}\right)} - \mu \epsilon \diffp[2]{\vec{\Pi_e}}{t}
\end{equation}
\begin{equation}
\vec{B} = \mu \varepsilon \left(\rot{\diffp{\vec{\Pi_e}}{t}}\right)
\end{equation}
E and B in terms of magnetic Hertz vector:
\begin{equation}
\vec{E} = \rot{\diffp{\vec{\Pi_m}}{t}}
\end{equation}
\begin{equation}
\vec{B} = \rot{\left(\rot{\vec{\Pi_m}}\right)}
\end{equation}
equations for Hertz vectors:
\begin{equation}
\left(\laplace{} - \mu \varepsilon \diffp[2]{}{t} \right) \vec{\Pi_e} = -\frac{\vec{P}\left(\vec{r} \right)}{\varepsilon}
\end{equation}
\begin{equation}
\left(\laplace{} - \mu \varepsilon \diffp[2]{}{t} \right) \vec{\Pi_m} = -\mu \vec{M}\left(\vec{r} \right)
\end{equation}
solutions:
\begin{equation}
\vec{\Pi_e}\left(\vec{r}, t \right) = \frac{1}{4 \pi \varepsilon} \int\limits_{V} \frac{\vec{P}\left(\vec{\tilde{r}} \right)}{\abs{\vec{r} - \vec{\tilde{r}}}} \mathrm{d} \tilde{V}
\end{equation}
\begin{equation}
\vec{\Pi_m}\left(\vec{r}, t \right) = \frac{\mu}{4 \pi} \int\limits_{V} \frac{\vec{M}\left(\vec{\tilde{r}} \right)}{\abs{\vec{r} - \vec{\tilde{r}}}} \mathrm{d} \tilde{V}
\end{equation}
Lorentz force:
\begin{equation}
\vec{F} = q \left(E + v \times B \right) 
\end{equation}
Ohm's law:
\begin{equation}
\vec{J} = \sigma \vec{E}
\end{equation}
Energy (Poynting) theorem:
\begin{equation}
\diffp{u}{t} + \div{\vec{S}} = - \vec{E} \cdot \vec{J}
\end{equation}
\begin{equation}
u = \frac{1}{2} \left(\vec{E} \cdot \vec{D} + \vec{H} \cdot \vec{B} \right)
\end{equation}
\begin{equation}
\int\limits_{S} \left(\vec{E} \times \vec{H} \right) \cdot \vec{n} \: \d \tilde{S} + \int\limits_{V} \vec{E} \cdot \vec{J} \: \d \tilde{V} = - \diffp{}{t} \int\limits_{V} \frac{1}{2} \left(\vec{E} \cdot \vec{D} + \vec{H} \cdot \vec{B} \right) \: \d \tilde{V}
\end{equation}
\begin{equation}
\vec{S} = \vec{E} \times \vec{H}
\end{equation}
\begin{equation}
\diffp{W}{t} = \int\limits_{V} \left(\vec{E} \cdot \diffp{\vec{D}}{t} + \vec{H} \cdot \diffp{\vec{B}}{t}\right) \: \d \tilde{V}
\end{equation}
wave equations:
\begin{equation}
\laplace{\vec{E}} - \frac{1}{c^{2}} \diffp[2]{\vec{E}}{t} = 0
\end{equation}
\begin{equation}
\laplace{\vec{B}} - \frac{1}{c^{2}} \diffp[2]{\vec{B}}{t} = 0
\end{equation}

\section{Gaussian Beam}
vector potential:
\begin{equation}
\vec{A}\left(\vec{r_\bot}, z, t \right)  = A_0 \Psi\left(\vec{r_\bot}, z \right) \e^{i \left(k_z z - \omega t \right)} \mathrm{\hat{e}_x}
\end{equation}
Helmholtz equation:
\begin{equation}
\laplace{\Psi} + 2 \i k_z \diffp{\Psi}{z} = 0
\end{equation}
dimensionless coordinates:
\begin{equation}
\rho = \frac{\norm{\vec{r_\bot}}}{w_0}, \quad \zeta = \frac{z}{z_r}
\end{equation}
where:
\begin{equation}
w_0, \quad z_r = k_z w_0^2/2
\end{equation}
after transformation:
\begin{equation}
\frac{1}{\rho} \diffp{}{\rho}\left(\rho \diffp{\Psi}{\rho} \right) + 4 \i \diffp{\Psi}{\zeta}  = - \theta^2 \diffp[2]{\Psi}{\zeta}
\end{equation}
where:
\begin{equation}
\theta = \frac{w_0}{z_R}
\end{equation}
zero-th order with transverse laplacian in cylindrical coords:
\begin{equation}
\frac{1}{\rho} \diffp{}{\rho}\left(\rho \diffp{\Psi_0}{\rho} \right) + 4 \i \diffp{\Psi_0}{\zeta} = 0
\end{equation}
solution in dimensionless coordinates:
\begin{equation}
\Psi_0 \left(\rho, \zeta \right) = \frac{1}{\sqrt{1 + \zeta^2}} \exp{\left(\i \frac{\rho^2 \zeta}{1 + \zeta^2} - \frac{\rho^2}{1 + \zeta^2} - \i \arctan{\left(\zeta\right)} \right)} 
\end{equation}
in Cartesian coordinates:
\begin{equation}
\Psi_0 \left(\vec{r_\bot}, z \right) = \frac{w_0}{w\left(z\right)} \exp{\left(\i k_z \frac{\vec{r_\bot}^2}{R\left(z \right)} - \frac{\vec{r_\bot}^2}{w\left(z \right)^2} - \varphi_G \left( z\right) \right)} 
\end{equation}
where:
\begin{equation}
w\left(z\right) = w_0 \sqrt{1 + \left(\frac{z}{z_R}\right)^2}, \quad R\left(z \right) = z \left[1 + \left(\frac{z_R}{z} \right)^2\right], \quad \varphi_G = \arctan{\left(\frac{z}{z_R}\right)}
\end{equation}
Solution - Gaussian beam:
\begin{equation*}
\vec{E}\left(x, y, z \right) = \vec{E_0} \frac{w_0}{w(z)} \exp \left( - \frac{x^2 + y^2}{w(z)^2} \right) \cos\left( \omega t - k_z \left(z + \frac{x^2 + y^2}{2R(z)} \right) + \phi_G(z) \right) 
\end{equation*}
where
\begingroup
\renewcommand*{\arraystretch}{2.0}
\begin{table}[h!]
\begin{flushleft}
\begin{tabular}{ l c r }
	$ w(z) = w_0 \sqrt{1 + \left(\frac{z}{z_R} \right)^2}  $ & \ldots & evolving beam width \\
	$ z_r = \frac{\pi w_0^2}{\lambda} $ & \ldots & Rayleigh range \\
	$ R(z) = z\left(1 + \left(\frac{z_R}{z} \right)^2 \right) $ & \ldots & radius of curvature \\
	$ \phi(z) = \tan^{-1}\left(\frac{z}{z_R} \right) $ & \ldots & Guoy phase 
	\end{tabular}
\end{flushleft}
\end{table}
\endgroup

\begin{flalign*}
& w(z) = w_0 \sqrt{1 + \left(\frac{z}{z_R} \right)^2} \dots \mathrm{evolving \: beam \: width} & \\
& z_r = \frac{\pi w_0^2}{\lambda} \dots \mathrm{Rayleigh \: range} & \\
& R(z) = z\left(1 + \left(\frac{z_R}{z} \right)^2 \right) \dots \mathrm{evolving \: radius \: of \: curvature} & \\
& \phi(z) = \tan^{-1}\left(\frac{z}{z_R} \right) \dots \mathrm{Guoy \: phase} & \\
& \theta = \tan^{-1}\left(\frac{w(z)}{z} \right) \simeq \frac{\lambda}{\pi w_0} \dots \mathrm{beam \: divergence \: angle} &
\end{flalign*}

\noindent
Features:
\begin{itemize}
	\item 2D version of algorithm, Ey, Bx, Bz omitted (identically equal to 0) 
	\item Code written in C++, object oriented to be easily extended to 3D, compiled to static library
	\item Linked into EPOCH as a static library (in order not to disturb the code, for this reason also added support for CMake – machine independent)
	\item Parallelized using hybrid techniques (OpenMP + MPI – computation time in most cases negligible in comparison with the main simulation)
	\item Fourier transforms can be computed using Intel MKL library, FFTW library or without any library (compile time option)
	\item Computed fields dumped into shared files using binary coding (speed up output, save disk storage)
	\item Only transverse component of electric field (Ex) passed to the EPOCH at each time step (no significant slowdown or memory overhead), other fields computed by EPOCH
	\item All new parameters needed for tight-focusing (w0, focal length, etc.) may be specified via input file
	\item Implementation works generally regardless the number of lasers in the simulation or boundaries that they are attached to
\end{itemize}

\noindent
Laser:
\begin{itemize}
\item wavelength: $ \lambda $ = 1.0 $ \mu m $
\item amplitude: $ \vec{E}_0 $ = 1e15 V/m
\item duration: t = 20 fs (in FWHM)
\item beam waist in focus: $ w_0 $ = 0.7 $ \mu m $
\item focus distance from boundary: $ x_\mathrm{B} - x_0 $ = 8 $ \mu m $
\item polarization: P
\item boundary: left 
\end{itemize}
Domain:
\begin{itemize}
\item x min: -8 $ \mu m $
\item x max: 8 $ \mu m $
\item y min: -8 $ \mu m $
\item y max: 8 $ \mu m $
\item $ N_x $: 1600 cells ($ \delta x $ = $ \lambda/100 $ = 10 nm)
\item $ N_y $: 1600 cells ($ \delta y $ = $ \lambda/100 $ = 10 nm)
\item time step: $ \delta t $ = $ 1/(\sqrt{2} c) \lambda /100 \approx $ 0.05 fs 
\item simulation time: $ \tau $ = 150 fs
\end{itemize}

\newpage
\noindent
The phase space distribution function  $ f_{s} \left(\vec{x}, \vec{v}, t\right) $ for a given species $ s $ is governed by the Vlasov equation:
\begin{equation*}
\diffp[]{f_{s}}{t} + \vec{v} \cdot \nabla f_s + \frac{q_{s}}{m_{s}}\left( \vec{E} + \vec{v} \times \vec{B} \right) \cdot \diffp[]{f_s}{\vec{v}} = 0.
\end{equation*}
The distribution function is approximated using finite-size quasi-particles with so-called shape functions $ S_{x} $ and $ S_{v} $, $ N_p $ is the number of physical particles: 
\begin{equation*}
f_{s} \left(\vec{x}, \vec{v}, t \right) =  \sum_{p} f_{p}\left(\vec{x}, \vec{v}, t \right), \quad f_{p}\left(\vec{x}, \vec{v}, t \right) = N_{p} S_{x}\left(\vec{x} - \vec{x}_{p}\left(t\right) \right)  S_{v}\left(\vec{v} - \vec{v}_{p}\left( t\right) \right).
\end{equation*}
Electromagnetic fields self-consistently evolved by Maxwell equations:
\begin{equation*}
\nabla \cdot \vec{E} = \frac{\rho}{\varepsilon_{0}}, \qquad \nabla \cdot \vec{B} = 0
\end{equation*}
\begin{equation*}
\nabla \times \vec{E} = - \diffp{\vec{B}}{t}, \qquad \nabla \times \vec{B} = \mu_{0} \vec{J} + \frac{1}{c^{2}} \diffp{\vec{E}}{t},
\end{equation*}
where charge density and current density are obtained from distribution functions:
\begin{equation*}
\rho\left(\vec{x}, t \right) = \sum_s q_s \int f_s \left(\vec{x}, \vec{v}, t \right) \mathrm{d} \vec{v}, \qquad \vec{J}\left(\vec{x}, t \right) = \sum_s q_s \int f_s \left(\vec{x}, \vec{v}, t \right) \vec{v} \, \mathrm{d} \vec{v}.
\end{equation*}



\begin{lstlisting}[style=CXX, caption=Function performing forward fast Fourier transform using MKL library]
std::vector<std::complex<double>> fft::mkl_fft_forward(std::vector<std::complex<double>> in) {
DFTI_DESCRIPTOR_HANDLE desc;
MKL_LONG status;
DftiCreateDescriptor(&desc, DFTI_DOUBLE, DFTI_COMPLEX, 1, static_cast<MKL_LONG>(in.size()));
DftiCommitDescriptor(desc);
status = DftiComputeForward(desc, in.data());
if(status != 0) {
std::cerr << DftiErrorMessage(status) << std::endl;
abort();
}
DftiFreeDescriptor(&desc);
return in;
}
\end{lstlisting}

\begin{lstlisting}[style=CXX, caption=Function performing backward fast Fourier transform using MKL library]
std::vector<std::complex<double>> fft::mkl_fft_backward(std::vector<std::complex<double>> in) {
DFTI_DESCRIPTOR_HANDLE desc;
MKL_LONG status;
DftiCreateDescriptor(&desc, DFTI_DOUBLE, DFTI_COMPLEX, 1, static_cast<MKL_LONG>(in.size()));
DftiCommitDescriptor(desc);
status = DftiComputeBackward(desc, in.data());
if(status != 0) {
std::cerr << DftiErrorMessage(status) << std::endl;
abort();
}
DftiFreeDescriptor(&desc);
return in;
}
\end{lstlisting}

\begin{lstlisting}[style=CXX, caption=Function performing forward fast Fourier transform using FFTW library]
std::vector<std::complex<double>> fft::fftw_fft_forward(std::vector<std::complex<double>> in) {
fftw_plan p = fftw_plan_dft_1d(in.size(), reinterpret_cast<fftw_complex*>(in.data()), reinterpret_cast<fftw_complex*>(in.data()), FFTW_FORWARD, FFTW_ESTIMATE);
fftw_execute(p);
fftw_destroy_plan(p);
return in;
}
\end{lstlisting}

\begin{lstlisting}[style=CXX, caption=Function performing backward fast Fourier transform using FFTW library]
std::vector<std::complex<double>> fft::fftw_fft_backward(std::vector<std::complex<double>> in) {
fftw_plan p = fftw_plan_dft_1d(in.size(), reinterpret_cast<fftw_complex*>(in.data()), reinterpret_cast<fftw_complex*>(in.data()), FFTW_BACKWARD, FFTW_ESTIMATE);
fftw_execute(p);
fftw_destroy_plan(p);
return in;
}
\end{lstlisting}

\begin{lstlisting}[style=CXX, caption=Function performing forward discrete Fourier transform without using any library]
std::vector<std::complex<double>> fft::fft_forward(std::vector<std::complex<double>> in) {
std::vector<std::complex<double>> out(in.size());
for(auto j = 0; j < out.size(); j++) {
for(auto l = 0; l < out.size(); l++) {
out.at(j) += in.at(l) * exp(-2.0 * constants::pi * I * l * j / in.size());
}
}
return out;
}
\end{lstlisting}

\begin{lstlisting}[style=CXX, caption=Function performing backward discrete Fourier transform without using any library]
std::vector<std::complex<double>> fft::fft_backward(std::vector<std::complex<double>> in) {
std::vector<std::complex<double>> out(in.size());
for(auto j = 0; j < out.size(); j++) {
for(auto l = 0; l < out.size(); l++) {
out.at(j) += in.at(l) * exp(+2.0 * constants::pi * I * l * j / in.size());
}
}
return out;
}
\end{lstlisting}

\begin{lstlisting}[style=CXX, caption=Method for performing discrete Fourier transform in time]
void laser_bcs::dft_time(field_2d<std::complex<double>>& field) const {
#ifdef OPENMP
#pragma omp parallel for schedule(static)
#endif
for(auto j = 0; j < this->domain->Nx; j++) {
#ifdef USE_MKL
field.add_col(fft::mkl_fft_backward(field.get_col(j)), j);
#elif USE_FFTW
field.add_col(fft::fftw_fft_backward(field.get_col(j)), j);
#else
field.add_col(fft::fft_backward(field.get_col(j)), j);
#endif
}
field.multiply(this->domain->dt / (2.0 * constants::pi));
return;
}
\end{lstlisting}

\begin{lstlisting}[style=CXX, caption=Method for performing inverse discrete Fourier transform in time]
void laser_bcs::idft_time(field_2d<std::complex<double>>& field) const {
#ifdef OPENMP
#pragma omp parallel for schedule(static)
#endif
for(auto j = 0; j < this->domain->Nx; j++) {
#ifdef USE_MKL
field.add_col(fft::mkl_fft_forward(field.get_col(j)), j);
#elif USE_FFTW
field.add_col(fft::fftw_fft_forward(field.get_col(j)), j);
#else
field.add_col(fft::fft_forward(field.get_col(j)), j);
#endif
}
field.multiply(2.0 * (2.0 * constants::pi) / (this->domain->Nt * this->domain->dt));
return;
}
\end{lstlisting}

\begin{lstlisting}[style=CXX, caption=Method for performing discrete Fourier transform in space]
void laser_bcs::dft_space(field_2d<std::complex<double>>& field) const {
std::vector<std::complex<double>> row_global(this->domain->Nx_global);
std::vector<std::complex<double>> row_local;
for(auto j = 0; j < this->domain->Nt; j++) {
row_local = field.get_row(j);
MPI_Gatherv(row_local.data(), this->domain->Nx, MPI_CXX_DOUBLE_COMPLEX, row_global.data(), this->domain->counts.data(), this->domain->displs.data(), MPI_CXX_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);
if(this->domain->rank == 0) {
#ifdef USE_MKL
row_global = fft::mkl_fft_forward(row_global);
#elif USE_FFTW
row_global = fft::fftw_fft_forward(row_global);
#else
row_global = fft::fft_forward(row_global);
#endif
}
MPI_Scatterv(row_global.data(), this->domain->counts.data(), this->domain->displs.data(), 	MPI_CXX_DOUBLE_COMPLEX, row_local.data(), this->domain->Nx, MPI_CXX_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);
field.add_row(row_local, j);
}
field.multiply(this->domain->dx / (2.0 * constants::pi));
return;
}
\end{lstlisting}

\begin{lstlisting}[style=CXX, caption=Method for performing inverse discrete Fourier transform in space]
void laser_bcs::idft_space(field_2d<std::complex<double>>& field) const {
std::vector<std::complex<double>> row_global(this->domain->Nx_global);
std::vector<std::complex<double>> row_local;
for(auto j = 0; j < this->domain->Nt; j++) {
row_local = field.get_row(j);
MPI_Gatherv(row_local.data(), this->domain->Nx, MPI_CXX_DOUBLE_COMPLEX, row_global.data(), this->domain->counts.data(), this->domain->displs.data(), MPI_CXX_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);
if(this->domain->rank == 0) {
#ifdef USE_MKL
row_global = fft::mkl_fft_backward(row_global);
#elif USE_FFTW
row_global = fft::fftw_fft_backward(row_global);
#else
row_global = fft::fft_backward(row_global);
#endif
}
MPI_Scatterv(row_global.data(), this->domain->counts.data(), this->domain->displs.data(), MPI_CXX_DOUBLE_COMPLEX, row_local.data(), this->domain->Nx, MPI_CXX_DOUBLE_COMPLEX, 0, MPI_COMM_WORLD);
field.add_row(row_local, j);
}
field.multiply((2.0 * constants::pi) / (this->domain->Nx_global * this->domain->dx));
return;
}
\end{lstlisting}

\begin{lstlisting}[style=CXX, caption=Method for dumping data into shared file]
template <typename T>
void field_2d<T>::dump_to_shared_file(std::string name, int row_first, int row_last, int row_size_local, int row_size_global, int col_start) const {
MPI_File file;
MPI_Offset offset = 0;
MPI_Status status;
MPI_Datatype local_array;
int col_size = row_last - row_first;
const int ndims = 2;
std::array<int, ndims> size_global = {col_size, row_size_global};
std::array<int, ndims> size_local = {col_size, row_size_local};
std::array<int, ndims> start_coords = {0, col_start};
MPI_Type_create_subarray(2, size_global.data(), size_local.data(), start_coords.data(), MPI_ORDER_C, MPI_DOUBLE, &local_array);
MPI_Type_commit(&local_array);
std::vector<double> real_part(col_size * row_size_local);
for(auto i = std::make_pair(row_first, 0); i.first < row_last; i.first++, i.second++) {
for(auto j = 0; j < row_size_local; j++) {
real_part[i.second * row_size_local + j] = std::real(this->data[i.first * row_size_local + j]);
}
}
MPI_File_open(MPI_COMM_WORLD, name.data(), MPI_MODE_CREATE|MPI_MODE_WRONLY, MPI_INFO_NULL, &file);
MPI_File_set_view(file, offset, MPI_DOUBLE, local_array, "native", MPI_INFO_NULL);
MPI_File_write_all(file, real_part.data(), col_size * row_size_local, MPI_DOUBLE, &status);
MPI_File_close(&file);
MPI_Type_free(&local_array);
return;
}
\end{lstlisting}

\begin{lstlisting}[style=CXX, caption=Extern C++ function to fill Fortran arrays with laser fields dumped in binary file]
void populate_laser_field_on_boundary(double* field, int* id, const char* data_dir, const char* name, int* timestep, int* size_global, int* first, int* last) {
double num = 0.0;
std::string laser_id = std::to_string(*id);
std::string output_path(data_dir);
std::string filename(name);
std::ifstream in;
in.open(output_path + "/" + filename + laser_id + ".dat", std::ios::binary);
if(in.is_open()) {
in.seekg(((*timestep) * (*size_global) + (*first) - 1) * sizeof(num));
for(auto i = 0; i < *last - *first + 1; i++) {
in.read(reinterpret_cast<char*>(&num), sizeof(num));
field[i] = num;
}
in.close();
} else {
std::cout << "error: cannot read file " << output_path + "/" + filename + laser_id + ".dat" << std::endl;
}
return;
}
\end{lstlisting}

\begin{lstlisting}[style=FORTRAN, caption=Fortran interfaces for C++ library functions]
INTERFACE

SUBROUTINE compute_laser_fields_on_boundary(rank, nproc, laser_start, laser_end, fwhm_time, t_0, omega, pos, amp, w_0, id, L_min, L_max, L_focus, T_min, T_max, T_ncells, cpml_thickness, t_end, T_cell_size, L_cell_size, dt, output_path) bind(c)
USE, INTRINSIC :: iso_c_binding
IMPLICIT NONE
INTEGER(c_int), INTENT(IN) :: rank, nproc, id, T_ncells, cpml_thickness
CHARACTER(kind=c_char), DIMENSION(*), INTENT(IN) :: output_path
REAL(c_double), INTENT(IN) :: laser_start, laser_end, fwhm_time, t_0, omega, pos,    &
amp, w_0, L_min, L_max, L_focus, T_min, T_max, t_end, T_cell_size, L_cell_size, dt
END SUBROUTINE compute_laser_fields_on_boundary

SUBROUTINE populate_laser_field_on_boundary(field, laser_id, output_path, field_name, timestep, size_global, first, last) bind(c)
USE, INTRINSIC :: iso_c_binding
IMPLICIT NONE
INTEGER(c_int), INTENT(IN) :: laser_id, timestep, size_global, first, last
CHARACTER(kind=c_char), DIMENSION(*), INTENT(IN) :: output_path, field_name
REAL(c_double), DIMENSION(*), INTENT(OUT) :: field
END SUBROUTINE populate_laser_field_on_boundary

END INTERFACE
\end{lstlisting}

\begin{lstlisting}[style=FORTRAN, caption=Fortran subroutines for Maxwell consistent computation of laser fields on boundaries]
SUBROUTINE Maxwell_consistent_computation_of_EM_fields

TYPE(laser_block), POINTER :: current

current => laser_x_min
DO WHILE(ASSOCIATED(current))
CALL compute_laser_fields_on_boundary(rank, nproc, current%t_start, current%t_end, current%fwhm_time, current%t_0, current%omega, current%pos, current%amp, current%w_0, current%id, x_min, x_max, current%focus, y_min, y_max, ny_global, cpml_thickness, t_end, dy, dx, dt, TRIM(data_dir)//C_NULL_CHAR)
current => current%next
ENDDO

current => laser_x_max
DO WHILE(ASSOCIATED(current))
CALL compute_laser_fields_on_boundary(rank, nproc, current%t_start, current%t_end, current%fwhm_time, current%t_0, current%omega, current%pos, current%amp, current%w_0, current%id, x_min, x_max, current%focus, y_min, y_max, ny_global, cpml_thickness, t_end, dy, dx, dt, TRIM(data_dir)//C_NULL_CHAR)
current => current%next
ENDDO

current => laser_y_min
DO WHILE(ASSOCIATED(current))
CALL compute_laser_fields_on_boundary(rank, nproc, current%t_start, current%t_end, current%fwhm_time, current%t_0, current%omega, current%pos, current%amp, current%w_0, current%id, y_min, y_max, current%focus, x_min, x_max, nx_global, cpml_thickness, t_end, dx, dy, dt, TRIM(data_dir)//C_NULL_CHAR)
current => current%next
ENDDO

current => laser_y_max
DO WHILE(ASSOCIATED(current))
CALL compute_laser_fields_on_boundary(rank, nproc, current%t_start, current%t_end, current%fwhm_time, current%t_0, current%omega, current%pos, current%amp, current%w_0, current%id, y_min, y_max, current%focus, x_min, x_max, nx_global, cpml_thickness, t_end, dx, dy, dt, TRIM(data_dir)//C_NULL_CHAR)
current => current%next
ENDDO

END SUBROUTINE Maxwell_consistent_computation_of_EM_fields
\end{lstlisting}

\begin{lstlisting}[style=FORTRAN, caption=Fortran subroutines for populating laser sources on boundaries]
SUBROUTINE get_source_x_boundary(source1, source2, laser_id) 
REAL(num), DIMENSION(:), INTENT(INOUT) :: source1, source2
REAL(num), DIMENSION(ny) :: laser_ex, laser_ey
INTEGER, INTENT(IN) :: laser_id
INTEGER :: i
CALL populate_laser_field_on_boundary(laser_ex, laser_id, TRIM(data_dir)//C_NULL_CHAR, "e_x"//C_NULL_CHAR, step, ny_global, ny_global_min, ny_global_max)
laser_ey = 0.0_num
DO i = 1, ny
source1(i) = source1(i) + laser_ex(i)
source2(i) = source2(i) + laser_ey(i)
ENDDO
END SUBROUTINE get_source_x_boundary

SUBROUTINE get_source_y_boundary(source1, source2, laser_id)
REAL(num), DIMENSION(:), INTENT(INOUT) :: source1, source2
REAL(num), DIMENSION(nx) :: laser_ex, laser_ey
INTEGER, INTENT(IN) :: laser_id
INTEGER :: i
CALL populate_laser_field_on_boundary(laser_ex, laser_id, TRIM(data_dir)//C_NULL_CHAR, "e_x"//C_NULL_CHAR, step, nx_global, nx_global_min, nx_global_max)
laser_ey = 0.0_num
DO i = 1, nx
source1(i) = source1(i) + laser_ey(i)
source2(i) = source2(i) + laser_ex(i)
ENDDO
END SUBROUTINE get_source_y_boundary
\end{lstlisting}